//
//  DataService.swift
//  ThinkBiz
//
//  Created by Han Yang Chin on 24/04/17.
//  Copyright Â© 2017 Han Yang Chin. All rights reserved.
//

import Foundation
import UIKit
import CoreData
import Firebase

enum Result<T> {
    case Success(T)
    case Error(String)
}

class DataService {
    
    // MARK: - Shared Instance
    
    static let sharedInstance: DataService = DataService()
    
    var viewContext: NSManagedObjectContext?
    
    // MARK: - Private
    
    private let dateFormatter: DateFormatter!
    private let dateFormat = "yyyy-MM-dd HH:mm:ss zzz"
    
    // Singleton
    private init() {
        // Init date formatter with format
        dateFormatter = DateFormatter()
        dateFormatter.dateFormat = dateFormat
    }
    
    // MARK: - Functions
    
    // MARK: CRUD Idea
    
    func addIdea(ideaData: Dictionary<String, Any>) -> Void {
        
        if let context = viewContext {
            
            // Create a new idea object
            let idea = Idea(context: context)
            idea.name = ideaData[IdeaKV.Name.rawValue] as? String
            idea.idea = ideaData[IdeaKV.Idea.rawValue] as? String
            idea.notes = ideaData[IdeaKV.Notes.rawValue] as? String
            idea.created = ideaData[IdeaKV.Created.rawValue] as? NSDate
            
            do {
                let refCloudIdea = ApiService.sharedInstance.REF_IDEAS.childByAutoId()
                
                // Update the uid generated by Firebase
                idea.uid = refCloudIdea.key
                
                // First make a modifyable copy
                var ideaDataCopy = ideaData
                
                // Also add the uid to data object before saving to the cloud
                ideaDataCopy[IdeaKV.UID.rawValue] = idea.uid
                
                // First convert the data to native type for cloud storage
                let cloudData = convertDataForCloud(data: ideaDataCopy)
                
                // Child updates are transactional
                if let refUserIdeas = ApiService.sharedInstance.REF_USER_IDEAS {
                    let childUpdates = ["\(refCloudIdea.key)": cloudData]
                    refUserIdeas.updateChildValues(childUpdates)
                }

                try context.save()
                print("Idea saved locally")

            } catch let error as NSError {
                print("\(error)")
            }
        }
    }
    
    func updateIdea(idea: Idea, ideaData: Dictionary<String, Any>) -> Void {

        if let context = viewContext {
            // Get updated properties from ideaData
            let updatedName = ideaData[IdeaKV.Name.rawValue] as? String ?? ""
            let updatedIdea = ideaData[IdeaKV.Idea.rawValue] as? String ?? ""
            let updatedNotes = ideaData[IdeaKV.Notes.rawValue] as? String ?? ""
            
            do {
                // Child updates are transactional
                if let refUserIdeas = ApiService.sharedInstance.REF_USER_IDEAS, let ideaUID = idea.uid {
                    let refUserIdea = refUserIdeas.child(ideaUID)
                    // When dealing with concurrency use run transaction block
                    refUserIdea.runTransactionBlock({ (currentMutableData: FIRMutableData) -> FIRTransactionResult in
                        // Get most recent idea from the cloud as dictionary
                        if var tempCloudIdea = currentMutableData.value as? [String: Any] {
                            tempCloudIdea[IdeaKV.Name.rawValue] = updatedName
                            tempCloudIdea[IdeaKV.Idea.rawValue] = updatedIdea
                            tempCloudIdea[IdeaKV.Notes.rawValue] = updatedNotes
                            
                            // Set and update mutable data dictionary with updated cloudIdea properties
                            currentMutableData.value = tempCloudIdea
                            
                            return FIRTransactionResult.success(withValue: currentMutableData)
                        }
                        return FIRTransactionResult.success(withValue: currentMutableData)
                    }, andCompletionBlock: { (error, completion, snapshot) in
                        if let error = error {
                            print(error.localizedDescription)
                        }
                    })
                }
                
                // TODO: Shift this saving core data code to observe event
                idea.name = updatedName
                idea.idea = updatedIdea
                idea.notes = updatedNotes
                
                try context.save()
                print("Updated idea")
            } catch let error as NSError {
                print("\(error)")
            }
        }

    }
    
    func deleteIdea(idea: Idea) -> Void {
        print("Deleting new idea")
        
        if let context = viewContext {
            if let refUserIdeas = ApiService.sharedInstance.REF_USER_IDEAS, let ideaUID = idea.uid {
                refUserIdeas.child(ideaUID).removeValue()
            }
            
            context.delete(idea)
            do {
                try context.save()
            } catch let error as NSError {
                print("\(error)")
            }
        }
    }
    
    func fetchIdeas(completion: @escaping (Result<[String: AnyObject]>) -> Void) {
        
        if let context = viewContext {
            if let refUserIdeas = ApiService.sharedInstance.REF_USER_IDEAS {
                // Only fetch once
                refUserIdeas.observeSingleEvent(of: .value, with: { (snapshot: FIRDataSnapshot) in
                    // Get user ideas
                    
                    let ideasDictionary = snapshot.value as? [String:AnyObject] ?? [:]

                    // First clear all ideas
                    self.clearIdeasFromCoreData()
                    
                    // Resave all updated ideas back to core data
                    self.saveIdeaInCoreDataWith(array: ideasDictionary)
                    
                    return completion(.Success(ideasDictionary))
                }, withCancel: { (error: Error) in
                    print("\(error)")
                    return completion(.Error(error.localizedDescription))
                })
            }
        }
//        return completion(.Error("Error fetching ideas"))
    }
    
    func fetchAndObserveIdeas(completion: @escaping (Result<[String: AnyObject]>) -> Void) -> UInt {
        if let refUserIdeas = ApiService.sharedInstance.REF_USER_IDEAS {
            
            // Listen for changes, should be fired first time when called, and any value changed
            let handle: UInt = refUserIdeas.observe(.value, with: { (snapshot: FIRDataSnapshot) in
                // Get user ideas
                
                let ideasDictionary = snapshot.value as? [String:AnyObject] ?? [:]
                
                // First clear all ideas
                self.clearIdeasFromCoreData()
                
                // Resave all updated ideas back to core data
                self.saveIdeaInCoreDataWith(array: ideasDictionary)
                
                return completion(.Success(ideasDictionary))
            }, withCancel: { (error: Error) in
                print("\(error)")
                return completion(.Error(error.localizedDescription))
            })
            
            return handle
        }
        return 0
    }
    
    func stopObservingUserIdeas(handle: UInt) {
        if let refUserIdeas = ApiService.sharedInstance.REF_USER_IDEAS {
            refUserIdeas.removeObserver(withHandle: handle)
            print("Removed Firebase handle \(handle)")
        }
    }
    
    // MARK: - Private functions
    
    private func convertDataForCloud(data: Dictionary<String, Any>) -> Dictionary<String, Any> {
        var tempData = data
        for key in tempData.keys {
            let item = tempData[key]
            if let date = item as? NSDate {
                let dateString = dateFormatter.string(from: date as Date)
                tempData[key] = dateString
            }
        }
        return tempData
    }
    
    private func saveIdeaInCoreDataWith(array: [String:AnyObject]) {
        
        guard array.count > 0 else {
            return
        }
        
        for (_, item) in array {
            let idea = item as! [String: AnyObject]
            _ = self.createIdeaEntityFrom(dictionary: idea)
        }
        do {
            if let context = viewContext {
                try context.save()
            }
        } catch let error {
            print(error)
        }
    }
    
    private func createIdeaEntityFrom(dictionary: [String: AnyObject]) -> NSManagedObject? {
        
        if let context = viewContext {
            if let ideaEntity = NSEntityDescription.insertNewObject(forEntityName: "Idea", into: context) as? Idea {
                // By default Firebase DB stores dates as Strings, therefore we need to convert it back to date format
                if let dateString = dictionary[IdeaKV.Created.rawValue] as? String {
                    ideaEntity.created = dateFormatter.date(from: dateString) as NSDate?
                }
                
                // Set the fields with values
                ideaEntity.idea = dictionary[IdeaKV.Idea.rawValue] as? String ?? ""
                ideaEntity.name = dictionary[IdeaKV.Name.rawValue] as? String ?? ""
                ideaEntity.notes = dictionary[IdeaKV.Notes.rawValue] as? String ?? ""
                ideaEntity.uid = dictionary[IdeaKV.UID.rawValue] as? String ?? ""
                
                return ideaEntity
            }
        }
        
        return nil
    }
    
    private func clearIdeasFromCoreData() {
        do {
            if let context = viewContext {
                let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "Idea")
                do {
                    let objects = try context.fetch(fetchRequest) as? [NSManagedObject]
                    _ = objects.map{$0.map{context.delete($0)}}
                    CoreDataStack.sharedInstance.saveContext()
                } catch let error {
                    print("Error deleting: \(error)")
                }
            }
        }
    }
    
}
